# <span style="color:blue">Webserv Project</span>

As part of the 1337 network curriculum, we've developed a project centered around constructing a simple HTTP server using C++. This project serves as a practical exercise to delve into the fundamentals of web server architecture and HTTP protocol implementation

## <span style="color:blue">Overview</span>

The Webserv project aims to implement a simple HTTP server capable of handling HTTP requests, serving static files, and potentially supporting CGI scripts. It provides an opportunity for learning about networking, system programming, and web development concepts.

## <span style="color:blue">What is a Web Server?</span>

A web server is a software application or program that runs on a computer and is responsible for serving web pages to clients over the internet or a local network. It receives HTTP requests from clients, typically web browsers, and sends back HTTP responses containing the requested content.

Here are some key points about web servers:

1. **HTTP Protocol**: Web servers primarily communicate using the Hypertext Transfer Protocol (HTTP), although they may also support HTTPS (HTTP Secure) for encrypted communication.
2. **Handling Requests**: When a client (such as a web browser) sends a request to a web server for a particular resource (such as a web page, image, or file), the web server processes the request and retrieves the requested resource.
3. **Serving Content**: Web servers can serve a variety of content types, including static files (such as HTML, CSS, JavaScript, images, and videos) and dynamic content generated by applications (such as web applications, APIs, or server-side scripts).
4. **Processing Requests**: Web servers can execute server-side scripts or applications to generate dynamic content in response to client requests. This often involves interacting with databases, processing user input, or performing other server-side computations.
5. **Configuration**: Web servers are typically highly configurable, allowing administrators to customize settings such as server behavior, virtual hosts, security policies, and performance optimizations.
6. **Concurrency**: Web servers are designed to handle multiple client connections simultaneously, often using techniques such as multi-threading or asynchronous I/O to achieve high concurrency and responsiveness.
7. **Security**: Web servers include features to enhance security, such as access control, authentication mechanisms, encryption (via HTTPS), and protection against common web attacks like DDoS attacks, SQL injection, and cross-site scripting (XSS) attacks.

## <span style="color:blue">Protocol and technique used in the project ?</span>

### <span style="color:blue">HTTP</span>

HTTP/1.1 (Hypertext Transfer Protocol 1.1) is a major revision of the HTTP network protocol used by the World Wide Web. It is the most widely used version of HTTP, having replaced HTTP/1.0.

Here are some key features and improvements introduced in HTTP/1.1:

1. **Persistent Connections**: HTTP/1.1 introduced persistent connections, also known as keep-alive connections, which allow multiple requests and responses to be sent over the same TCP connection. This reduces the overhead of establishing and tearing down connections for each request/response pair, improving performance.
2. **Chunked Transfer Encoding**: HTTP/1.1 introduced chunked transfer encoding, which allows a server to send a response message as a series of chunks. This is particularly useful when the size of the response is unknown at the beginning of the transmission or when the response is generated dynamically.
3. **Host Header**: HTTP/1.1 requires the inclusion of a Host header in every request. This allows a single server to host multiple websites using virtual hosting, where different websites are distinguished by the Host header.
4. **Range Requests**: HTTP/1.1 introduced support for range requests, allowing clients to request only a portion of a resource rather than the entire resource. This is useful for resuming interrupted downloads or downloading large files in smaller chunks.
5. **Cache Control**: HTTP/1.1 introduced more sophisticated caching mechanisms, including cache control headers such as Cache-Control and ETag, allowing servers and clients to specify caching behavior more precisely.
6. **Content Negotiation**: HTTP/1.1 expanded content negotiation capabilities, allowing servers to serve different versions of a resource based on factors such as language, content encoding, and media type preferences specified by the client.

### <span style="color:blue">I/O Multiplexing</span>

I/O multiplexing is a technique used in computer programming and operating systems to manage multiple input/output (I/O) operations concurrently without the need for multiple threads or processes. It allows a single process or thread to monitor multiple I/O streams (such as sockets, files, or pipes) and respond to events on these streams efficiently.

The main advantage of I/O multiplexing is that it enables a program to handle many I/O operations concurrently with a small number of threads or processes, reducing resource consumption and simplifying programming complexity.

There are several mechanisms for implementing I/O multiplexing, including:

1. **Select**: The `select` system call is a basic form of I/O multiplexing available in many operating systems. It allows a program to monitor multiple file descriptors for readability, writability, or exceptional conditions (e.g., errors or out-of-band data).
2. **Poll**: The `poll` system call is similar to `select` but provides a more efficient mechanism for monitoring multiple file descriptors. It uses a data structure called a pollfd array to specify the file descriptors to monitor and their associated events.
3. **Epoll (Linux)**: Epoll (event poll) is a scalable and high-performance I/O event notification mechanism available on Linux systems. It improves upon the limitations of `select` and `poll` by using a scalable data structure to efficiently handle large numbers of file descriptors.
4. **Kqueue (FreeBSD, macOS)**: Kqueue (kernel event queue) is a similar mechanism to epoll available on FreeBSD and macOS systems. It provides efficient event notification for various types of I/O events, including file descriptors, signals, and timers.
5. **IOCP (Windows)**: IOCP (Input/Output Completion Ports) is a mechanism available on Windows systems for asynchronous I/O operations. It allows a program to submit I/O operations and receive notifications when they complete, enabling high-performance network servers and other I/O-bound applications.


### <span style="color:blue">Wath is CGI ? </span>

CGI stands for Common Gateway Interface. It's a standard protocol for enabling web servers to execute external programs or scripts and return dynamic content to a client's web browser.

Here's how CGI typically works:

1. **Client Request**: A client (usually a web browser) sends an HTTP request to the web server. This request may include parameters or data.
2. **Web Server Processing**: The web server receives the request and identifies that it requires processing by a CGI program. The server typically identifies CGI programs based on file extensions (e.g., `.cgi`, `.pl`, `.py`).
3. **CGI Execution**: The web server launches the specified CGI program, passing any parameters or data from the client request to the program through environment variables, command-line arguments, or standard input.
4. **Program Execution**: The CGI program executes on the server, performing any necessary computations, database queries, or other tasks to generate dynamic content.
5. **Content Generation**: The CGI program generates HTML or other content dynamically based on its processing of the client request and any external data sources.
6. **Server Response**: The CGI program sends the generated content back to the web server through standard output.
7. **Server Response to Client**: The web server sends the dynamic content received from the CGI program back to the client's web browser as part of the HTTP response.

Common uses of CGI include:

- Generating dynamic web pages based on user input or database queries.
- Handling form submissions and processing user input.
- Providing interactive web applications and services.


### <span style="color:blue">Functions Used</span>

- `execve`: Loads and executes a new program into the current process.
- `dup`, `dup2`: Duplicates an open file descriptor.
- `strerror`, `gai_strerror`: Retrieves error strings for system and networking errors.
- `errno`: Global variable indicating errors.
- `fork`: Creates a new process.
- `socketpair`: Creates a pair of connected sockets for inter-process communication.
- `htons`, `htonl`, `ntohs`, `ntohl`: Functions for byte order conversion.
- `select`, `poll`: I/O multiplexing functions for monitoring file descriptors.
- `epoll` (`epoll_create`, `epoll_ctl`, `epoll_wait`): High-performance I/O multiplexing mechanism on Linux.
- `kqueue` (`kqueue`, `kevent`): Event notification mechanism on FreeBSD and macOS.
- `socket`, `bind`, `connect`: Functions for socket creation, binding, and connection establishment.
- `getaddrinfo`, `freeaddrinfo`: Resolves hostnames and service names to socket addresses.
- `setsockopt`, `getsockname`: Socket options and local address retrieval.
- `getprotobyname`: Retrieves protocol information by name.
- `fcntl`: Performs operations on file descriptors.
- `close`: Closes a file descriptor.
- `read`, `write`: Reads from or writes to a file descriptor.
- `waitpid`: Waits for child process state changes.
- `kill`: Sends signals to processes.
- `signal`: Sets signal handlers.
- `access`: Checks file or directory access permissions.
- `stat`: Retrieves file status information.
- `open`, `opendir`, `readdir`, `closedir`: File and directory manipulation functions.
